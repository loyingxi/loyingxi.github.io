{"posts":[{"title":"网页禁用F12","content":"网页禁用F12，禁止审查元素，屏蔽复制，禁用鼠标右键。 禁用任何键盘敲击事件（防止F12和shift+ctrl+i调起开发者工具）。 window.onload = function () { //禁止F12 $(&quot;*&quot;).keydown(function (e) {//判断按键 e = window.event || e || e.which; if (e.keyCode == 123) { e.keyCode = 0; return false; } }); //禁止审查元素 $(document).bind(&quot;contextmenu&quot;,function(e){ return false; }); }; //屏蔽复制 document.oncopy = function (event){ if(window.event){ event = window.event; } try{ var the = event.srcElement; if(!((the.tagName == &quot;INPUT&quot; &amp;&amp; the.type.toLowerCase() == &quot;text&quot;) || the.tagName == &quot;TEXTAREA&quot;)){ return false; } return true; }catch (e){ return false; } }; //屏蔽张贴 document.onpaste = function (event){ if(window.event){ event = window.event; } try{ var the = event.srcElement; if (!((the.tagName == &quot;INPUT&quot; &amp;&amp; the.type.toLowerCase() == &quot;text&quot;) || the.tagName == &quot;TEXTAREA&quot;)){ return false; } return true; }catch (e){ return false; } } //禁用Ctrl + s window.addEventListener('keydown', function (e) { if(e.keyCode == 83 &amp;&amp; (navigator.platform.match('Mac') ? e.metaKey : e.ctrlKey)){ e.preventDefault(); } }); //禁止右键 document.oncontextmenu = function(e) {alert('别看啦，宝宝好羞涩*^_^');return false;}; //禁止任何键盘敲击事件（防止F12和shift+ctrl+i调起开发者工具） window.onkeydown = window.onkeyup = window.onkeypress = function () { window.event.returnValue = false; return false; } ","link":"https://loyingxi.github.io/post/jinyongf12/"},{"title":"C#调用Web接口获取数据简易实现","content":" 实现代码 开头需要引用System.IO，System.Net两个命名空间。 using System.IO; using System.Net; GET请求 //此处自定义函数HttpGet public static string HttpGet(string url) { Encoding encoding = Encoding.UTF8;//编码方式，此处为UTF-8 HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);//创建Http请求 request.Method = &quot;GET&quot;;//请求方法，此处为GET request.Accept = &quot;text/html, application/xhtml+xml, */*&quot;;//媒体类型 request.ContentType = &quot;application/json&quot;;//JSON数据格式 request.Timeout = 20000;//超时时间,以毫秒为单位 HttpWebResponse response = (HttpWebResponse)request.GetResponse();//发送请求 using (StreamReader reader = new StreamReader(response.GetResponseStream(), Encoding.UTF8)) { return reader.ReadToEnd();//返回数据 } } POST请求 //此处自定义函数HttpPost public static string HttpPost(string url) { Encoding encoding = Encoding.UTF8;//编码方式，此处为UTF-8 HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);//创建Http请求 request.Method = &quot;Post&quot;;//请求方法，此处为GET request.Accept = &quot;text/html, application/xhtml+xml, */*&quot;;//媒体类型 request.ContentType = &quot;application/json&quot;;//JSON数据格式 request.Timeout = 20000;//超时时间,以毫秒为单位 HttpWebResponse response = (HttpWebResponse)request.GetResponse();//发送请求 using (StreamReader reader = new StreamReader(response.GetResponseStream(), Encoding.UTF8)) { return reader.ReadToEnd();//返回数据 } } 调用函数 上面的代码是定义了用于发送请求的函数，在实际使用中还需要调用自定义的函数来实现，当然你也可以不定义函数直接使用。 //函数名(&quot;URL&quot; + 参数); string a = 1; string b = HttpGet(&quot;http://www.xxx.com/api.php?a=&quot; + a); ","link":"https://loyingxi.github.io/post/100001/"},{"title":"软件更新设计思路","content":"更新文件方法 在确定存在新版本以后，下一步就是更新本地文件。方法同样也很多，就只说我自己的思路吧。 更新程序和主程序分离，为两个独立的EXE，更新在主程序根目录下的一个文件夹内。在主程序打开更新程序验证完更新信息开始下载以后，首先关闭主程序，然后遍历根目录下所有文件，遇到文件便删除，遇到文件夹不做任何操作（建立文件夹存放更新程序的原因），然后便从远程地址下载程序压缩包到更新文件夹，解压到主程序根目录，删除压缩包，最后退出更新程序打开主程序（当然不是最开始的那个主程序了）。 这就是全部思路，梳理完后你会发现其实实现更新功能很简单。 实现代码 我只给关键的代码，也不会说该放哪些控件。本文中所有代码均在SuperBuster项目中。 判断更新 //此处自定义函数HttpGet public static string HttpGet(string url) { Encoding encoding = Encoding.UTF8;//编码方式，此处为UTF-8 HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);//创建Http请求 request.Method = &quot;GET&quot;;//请求方法，此处为GET request.Accept = &quot;text/html, application/xhtml+xml, */*&quot;;//媒体类型 request.ContentType = &quot;application/json&quot;;//JSON数据格式 request.Timeout = 20000;//超时时间,以毫秒为单位 HttpWebResponse response = (HttpWebResponse)request.GetResponse();//发送请求 using (StreamReader reader = new StreamReader(response.GetResponseStream(), Encoding.UTF8)) { return reader.ReadToEnd();//返回数据 } } 全局变量Version（字符串）为当前程序版本。获取文件内容，将html文件中的版本号用全局变量b（字符串）储存，通过两变量对比判断更新。 try { button1.Enabled = false; label1.Text = &quot;正在检查更新......&quot;; b = HttpGet(&quot;http://www.loyingxi.eu.org/AppVersion.html&quot;); if (b != Version) { MessageBox.Show(&quot;发现新版本！最新版本为：&quot; + b, &quot;提示&quot;); button1.Enabled = true; button2.Enabled = true; } else { MessageBox.Show(&quot;当前为最新版本！&quot;, &quot;提示&quot;); button1.Enabled = true; } } catch { MessageBox.Show(&quot;未知错误！&quot;, &quot;提示&quot;); button1.Enabled = true; } 删除旧版本文件 首先获取父目录，因为更新程序在主程序根目录下的子目录中。然后遍历所有文件以及目录。因为项目中只有一个文件夹（存放更新程序），所以遇到目录不处理就好，遇到文件便删除。不同项目设计不同，如果你的项目中根目录下的目录不止更新目录一个，那么就要费点心重新想重新写了（当然还有很多种方法）。 DirectoryInfo info = new DirectoryInfo(Application.StartupPath); string a = info.Parent.FullName; DirectoryInfo dir = new DirectoryInfo(a); FileSystemInfo[] fileinfo = dir.GetFileSystemInfos(); foreach (FileSystemInfo i in fileinfo) { if (i is DirectoryInfo) { } else { File.Delete(i.FullName); } } 下载新版本压缩包 下载文件本来是很复杂的操作，要写很多代码，但是WebClient类让下载变得非常轻松。通过WebClient把新版本压缩包下载保存到更新程序所在的目录。 WebClient webClient = new WebClient(); webClient.DownloadFile(new Uri(&quot;http://www.loyingxi.eu.org/files/App.zip&quot;), &quot;Latest.zip&quot;); 解压压缩包 通过ZipFile类，解压文件到原来的主程序根目录下，然后删除压缩包。 ZipFile.ExtractToDirectory(Directory.GetCurrentDirectory() + &quot;/Latest.zip&quot;, a); File.Delete(&quot;Latest.zip&quot;); 更新功能到此就完成了，非常的简单。当然这个例子中仍然有很多不足的地方，比如如果主程序根目录下不止一个子目录，要增加额外的判断或者换思路，没有备份，如果更新失败如中途退出，那么删除的文件无法恢复等等。大家可以自己完善！ ","link":"https://loyingxi.github.io/post/ruan-jian-geng-xin-she-ji-si-lu/"},{"title":"免费申请顶级域名","content":"免费的 http://eu.org 域名【申请教程】 废话不多说，教程开始！ 今天申请的域名后缀为**【.http://eu.org】，可能大家比较熟悉的只是【.org】，【.http://eu.org】**应该是没见到过的吧！ PS：http://eu.org是欧盟组织下面的域名，EU代表欧盟，Paul Mockapetris在1996年的9-10月份创建了这个域名的DNS服务器，计划是专门给无力承担费用的一些组织使用的。所以它对个人和组织是免费注册的。目前已经被谷歌，cf等一些大公司认可为顶级域名。 打开注册地址：https://nic.eu.org/，然后点击【here】。 然后在出现的这个页面点击【Register】按钮。 然后就来到了注册页面。该注册页面需要填写的信息非常简单，除了【E-mail】哪项需要填写自己真实的邮箱，其它的直接使用一个英国地址生成器网站：https://www.meiguodizhi.com/uk-address 就可以搞定了。 对应的填写方法如下： Name：全名+性别（中间是空格） E-mail：自己真实的邮箱，等下需要收取验证链接的。我用的QQ邮箱，实测没有问题 Address (line 1)：街道+城市（中间是空格） Address (line 2)：州 Phone和Fax：电话号码 “I have read and I accept the domain policy”需要勾选起来 “Password”填写的是你的登录密码；“Confirm Password”是确认密码，这个等下就会用到的，请务必记下来 填完后点击【Create】按钮。 然后你填写的邮箱就会收到一封邮件，如果你超过30秒还没收到，就去你邮箱里面的垃圾箱找找看。我这面的QQ邮箱几乎是3秒就有提示了，点开后是英文邮件，好在QQ邮箱自带翻译，所以我点击了“立即翻译”按钮。 翻译之后可以看到它其实是一个激活邮件，我们按照提示点击它给出的链接进行激活验证。 点击“Validate”（验证）按钮。 点击&quot;Login&quot;（登录）按钮。 然后在这个页面输入登录的账号和密码。 Handle（账号）：就是给你发的电子邮件**“nic-hdl”**后面的信息就是 Password（密码）：前面你注册的时候填写的登录密码 完成之后点击“Login”按钮进入下一步。 、 点击“New Domain”（创建）按钮。 然后在该页面输入你想注册的域名，数字或者字母都可以。需要注意的是：后面必须加上【.http://eu.org】后缀。比如我这里填写的是“smzdm.eu.org” 然后重新打开浏览器另外一个标签页，打开腾讯DNSPOD：https://www.dnspod.cn/，登录自己的账号（没有就直接注册一个，可以微信扫码快速注册，非常简单），然后点击右上角的“管理控制台”。 点击“我的域名”。 点击“添加域名” 在方框内输入我们在上个网站需要注册的那个域名，然后点击“确定“按钮”。 然后就会弹出这个“未使用DNSPod解析服务“的提示，我们可以暂时不管，但是需要复制图片红色方框里面的两个网址。 然后回到我们刚刚创建域名的网站，还是同一页面的下方，也就是上图的位置，首选选择“server names”，然后在Name1和Name2里面分别填入我们刚刚在腾讯DNSPOD复制的两个网址（其实这个是为我们申请到的域名托管到cloudflare做准备）。完成之后点击“Submit”按钮。 当出现上图中&quot;No error...Done&quot;，就说明成功了~然后就是等待审核时间。审核快点的可能不到一天，慢点的需要一个月也有可能。 不过我可以告诉大家一个小技巧，你完成之后可以回到这个页面继续创建另外一个域名，也是同样的操作。一个账号貌似可以创建4个域名，这样的好处就是你总会有个域名短时间内就能通过审核的。 比如说我其中另外一个不到一天就通过审核了。通过审核的域名会直接通过邮箱来通知我们的。 并且在我们创建域名的那个网站下面也能看到。 当我们使用通过审核的这个域名再添加到腾讯DNSPOD的时候，看见没有，直接显示正常了，也就是说可以解析了。 然后解析的具体操作步骤请参考我之前的【7元钱就能拥有一个个性域名，并且用它搭建群晖外网访问的具体教程】这篇文章。 最后给大家看看我群晖NAS上添加的DDNS ，用的就是申请的这个域名。 外网访问当然也是没有任何问题的。简单来说，就是白P成功！ 不过需要说明的是，这个域名也只是不花钱，随意玩玩而已，貌似国内是无法备案的。但是NAS用户用它来作为DDNS的域名解析还是没有任何问题的。 至此，今天的教程到此结束。 好了，以上就是今天给大家分享的内容，我是爱分享的Stark-C，如果今天的内容对你有帮助请记得收藏，顺便点点关注，我会经常给大家分享各类有意思的软件和免费干货！谢谢大家~~ ","link":"https://loyingxi.github.io/post/mian-fei-shen-qing-ding-ji-yu-ming/"},{"title":"MySQL创建定时任务","content":"MySQL创建定时任务 一、前言 自MySQL5.1.6起，增加了一个非常有特色的功能-事件调度器（Event Scheduler），可以用做定时执行某些特定任务（例如：删除记录、对数据进行汇总、数据备份等等），来取代原先只能由操作系统的计划任务来执行的工作。更值得一提的是MySQL的事件调度器可以精确到每秒钟执行一个任务，而操作系统的计划任务（如：Linux的cron或Windows下的任务计划）只能精确到每分钟执行一次。对于一些对数据实时性要求比较高的应用（例如：股票、赔率、比分等）就非常适合。 事件调度器有时也可以称为临时触发器（temporal triggers），因为事件调度器是基于特定时间周期触发来执行某些任务，而触发器（Triggers）是基于某个表所产生的事件触发的，区别也就在这里。 1、在使用这个功能之前必须确保event_scheduler已开启，可执行 SET GLOBAL event_scheduler = 1; ---或我们可以在配置my.cnf文件 中加上 event_scheduler = 1 或 SET GLOBAL event_scheduler = ON; 来开启，也可以直接在启动命令加上“--event_scheduler=1”，例如： mysqld ... --event_scheduler=1 注：将事件计划关闭：SET GLOBAL event_scheduler = 0; 2、要查看当前是否已开启事件调度器，可执行如下SQL： SHOW VARIABLES LIKE 'event_scheduler'; 或 SELECT @@event_scheduler; 或 SHOW PROCESSLIST; 注： （1）关闭事件任务： ALTER EVENT eventName ON COMPLETION PRESERVE DISABLE; （2）开启事件任务：ALTER EVENT eventName ON COMPLETION PRESERVE ENABLE; （3）查看事件任务：SHOW EVENTS ; 二、创建事件 先来看一下他的语法： CREATE EVENT [IFNOT EXISTS] event_name ONSCHEDULE schedule [ONCOMPLETION [NOT] PRESERVE] [ENABLE | DISABLE] [COMMENT 'comment'] DO sql_statement; schedule: AT TIMESTAMP [+ INTERVAL INTERVAL] | EVERY INTERVAL [STARTS TIMESTAMP] [ENDS TIMESTAMP] INTERVAL: quantity {YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE | WEEK | SECOND | YEAR_MONTH | DAY_HOUR | DAY_MINUTE | DAY_SECOND | HOUR_MINUTE | HOUR_SECOND | MINUTE_SECOND} 1) 首先来看一个简单的例子来演示每秒插入一条记录到数据表 USE td2; CREATE TABLE aaa(timeline TIMESTAMP); CREATE EVENT e_test_insert ON SCHEDULE EVERY 1 SECOND DO INSERT aaa VALUE(CURRENT_TIMESTAMP); 等待3秒之后，再执行查询看看 SELECT * FROM aaa; 2) 5天后清空test表： CREATE EVENT e_test ON SCHEDULE AT CURRENT_TIMESTAMP+INTERVAL 5 DAY DO TRUNCATE TABLE aaa; 3) 2007年7月20日12点整清空test表： CREATE EVENT e_test1 ON SCHEDULE AT TIMESTAMP '2018-09-17 18:16:00' DO TRUNCATE TABLE aaa; 4) 每天定时清空test表： CREATE EVENT e_test2 ON SCHEDULE EVERY 1 DAY DO TRUNCATE aaa; 5) 5天后开启每天定时清空test表： CREATE EVENT e_test3 ON SCHEDULE EVERY 1 DAY STARTS CURRENT_TIMESTAMP+INTERVAL 5 DAY DO TRUNCATE aaa; 6) 每天定时清空test表，5天后停止执行： CREATE EVENT e_test4 ON SCHEDULE EVERY 1 DAY ENDS CURRENT_TIMESTAMP+INTERVAL 5 DAY DO TRUNCATE aaa; 7) 5天后开启每天定时清空test表，一个月后停止执行： CREATE EVENT e_test5 ON SCHEDULE EVERY 1 DAY STARTS CURRENT_TIMESTAMP+INTERVAL 5 DAY ENDS CURRENT_TIMESTAMP+INTERVAL 1 MONTH DO TRUNCATE aaa; [ON COMPLETION [NOT] PRESERVE]可以设置这个事件是执行一次还是持久执行，默认为NOT PRESERVE。 8) 每天定时清空test表(只执行一次，任务完成后就终止该事件)： CREATE EVENT e_test6 ON SCHEDULE EVERY 1 DAY ON COMPLETION NOT PRESERVE DO TRUNCATE aaa; [ENABLE | DISABLE]可以设置该事件创建后状态是否开启或关闭，默认为ENABLE。 [COMMENT ‘comment’]可以给该事件加上注释。 三、修改事件 先来看一下他的语法： ALTER EVENT event_name [ONSCHEDULE schedule] [RENAME TOnew_event_name] [ON COMPLETION [NOT] PRESERVE] [COMMENT 'comment'] [ENABLE | DISABLE] [DO sql_statement] 1) 临时关闭事件 ALTER EVENT e_test DISABLE; 2) 开启事件 ALTER EVENT e_test ENABLE; 3) 将每天清空test表改为5天清空一次： ALTER EVENT e_test ON SCHEDULE EVERY 5 DAY; 四、删除事件 先来看一下他的语法： DROP EVENT [IF EXISTS] event_name 例如删除前面创建的e_test事件 DROP EVENT e_test; 当然前提是这个事件存在，否则会产生ERROR 1513 (HY000): Unknown event错误，因此最好加上IF EXISTS DROP EVENT IF EXISTS e_test; 注意：如果你将event执行了Alter event event_name disable.那么当你重新启动mysql服务 器后，该event将被删除（测试版本：5.1.30） 备注：在event事件中：ON SCHEDULE 计划任务，有两种设定计划任务的方式： （1）AT 时间戳，用来完成单次的计划任务 （2）EVERY 时间（单位）的数量实践单位[STARTS 时间戳] [ENDS时间戳]，用来完成重复的计划任务。 在两种计划任务中，时间戳可以是任意的TIMESTAMP 和DATETIME 数据类型，时间戳需要大于当前时间。 在重复的计划任务中，时间（单位）的数量可以是任意非空（Not Null）的整数式，时间单位是关键词：YEAR，MONTH，DAY，HOUR，MINUTE 或者SECOND。 提示: 其他的时间单位也是合法的如：QUARTER, WEEK, YEAR_MONTH,DAY_HOUR,DAY_MINUTE,DAY_SECOND,HOUR_MINUTE,HOUR_SECOND, MINUTE_SECOND，不建议使用这些不标准的时间单位。 [ON COMPLETION [NOT] PRESERVE]：ON COMPLETION参数表示&quot;当这个事件不会再发生的时候&quot;，即当单次计划任务执行完毕后或当重复性的计划任务执行到了ENDS阶段。而PRESERVE的作用是使事件在执行完毕后不会被Drop掉，建议使用该参数，以便于查看EVENT具体信息。 五、应用案例 本案例是利用 event scheduler 的特性，每秒钟调用一次存储过程，用于判断 SLAVE 是否正常运行，如果发现 SLAVE 关闭了，忽略 0 次错误，然后重新启动 SLAVE。 1）首先创建存储过程 CREATE PROCEDURE Slave_Monitor() BEGIN SELECT VARIABLE_VALUE INTO @SLAVE_STATUS FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME='SLAVE_RUNNING'; IF('ON'!=@SLAVE_STATUS) THEN SET GLOBAL SQL_SLAVE_SKIP_COUNTER=0; SLAVE START; END IF; END; 由于存储过程中无法调用类似 SHOW SLAVE STATUS 这样的语句，因此无法得到确切的复制错误信息和错误代码，不能进一步的处理 SLAVE 停止的各种情况。 2）接着，创建任务 CREATE EVENT IF NOT EXISTS Slave_Monitor ON SCHEDULE EVERY 5 SECOND ON COMPLETION PRESERVE DO CALL Slave_Monitor(); 创建了一个任务，每 5秒钟执行一次，任务结束后依旧保留该任务，而不是删除。当然了，在本例中的任务不会结束，除非将它手动禁止了。 如果在运行中想要临时关闭一下某个任务，执行 ALTER EVENT 语句即可： ALTER EVENT Slave_Monitor ON COMPLETION PRESERVE DISABLE; ##关闭事件ALTER EVENT Slave_Monitor ON COMPLETION PRESERVE ENABLE; ##开启事件 ","link":"https://loyingxi.github.io/post/mysql-chuang-jian-ding-shi-ren-wu/"},{"title":"使用cloudflare制作“镜像站”","content":"使用cloudflare制作“镜像站” 可以用于间接访问一些打不开的网站，例如Github 注意：Cloudflare是有官方中文的，在界面的右上角可以选择语言。 从官网注册之后，会跳转到转到 https://dash.cloudflare.com/，接下来的步骤都是在控制台进行的。 在控制面板主页左侧可以找到workers。如图所示，中间可以创建服务，右侧显示每天的额度，如果只是搭建个人服务这些额度绰绰有余了（但是放在网上公开使用大概率会用完，这也是我推荐大家自己搭建的原因）。下方会显示所有已经搭建的服务。 image-20220502110006820 创建服务，随便填写一个即可，记住下面这个https://xxxx.xxx.workers.dev，此即镜像站的网址。 注意服务名称 等待部署完成，回到 https://dash.cloudflare.com/，workers-点击刚刚创建的项目。转到控制界面，可以找到右下角有一个快速编辑的按钮。 个人觉得这个设计十分反人类 打开这个窗口，把代码以下复制进去，保存部署，然后直接访问之前我们记下的链接就好了（也可以在控制台看到）。 这是镜像zlibrary的示例，你也可以修改成镜像GitHub。 image-20220502111948254 // 你要镜像的网站. const upstream = 'zh.u1lib.org' // 镜像网站的目录，比如你想镜像某个网站的二级目录则填写二级目录的目录名，镜像 google 用不到，默认即可. const upstream_path = '/' // 镜像站是否有手机访问专用网址，没有则填一样的. const upstream_mobile = 'zh.u1lib.org' // 屏蔽国家和地区. const blocked_region = ['KP', 'SY', 'PK', 'CU'] // 屏蔽 IP 地址. const blocked_ip_address = ['0.0.0.0', '127.0.0.1'] // 镜像站是否开启 HTTPS. const https = true // 文本替换. const replace_dict = { '$upstream': '$custom_domain', '//zh.u1lib.org': '' } // 以下保持默认，不要动 addEventListener('fetch', event =&gt; { event.respondWith(fetchAndApply(event.request)); }) async function fetchAndApply(request) { const region = request.headers.get('cf-ipcountry').toUpperCase(); const ip_address = request.headers.get('cf-connecting-ip'); const user_agent = request.headers.get('user-agent'); let response = null; let url = new URL(request.url); let url_hostname = url.hostname; if (https == true) { url.protocol = 'https:'; } else { url.protocol = 'http:'; } if (await device_status(user_agent)) { var upstream_domain = upstream; } else { var upstream_domain = upstream_mobile; } url.host = upstream_domain; if (url.pathname == '/') { url.pathname = upstream_path; } else { url.pathname = upstream_path + url.pathname; } if (blocked_region.includes(region)) { response = new Response('Access denied: WorkersProxy is not available in your region yet.', { status: 403 }); } else if (blocked_ip_address.includes(ip_address)) { response = new Response('Access denied: Your IP address is blocked by WorkersProxy.', { status: 403 }); } else { let method = request.method; let request_headers = request.headers; let new_request_headers = new Headers(request_headers); new_request_headers.set('Host', url.hostname); new_request_headers.set('Referer', url.hostname); let original_response = await fetch(url.href, { method: method, headers: new_request_headers }) let original_response_clone = original_response.clone(); let original_text = null; let response_headers = original_response.headers; let new_response_headers = new Headers(response_headers); let status = original_response.status; new_response_headers.set('access-control-allow-origin', '*'); new_response_headers.set('access-control-allow-credentials', true); new_response_headers.delete('content-security-policy'); new_response_headers.delete('content-security-policy-report-only'); new_response_headers.delete('clear-site-data'); const content_type = new_response_headers.get('content-type'); if (content_type.includes('text/html') &amp;&amp; content_type.includes('UTF-8')) { original_text = await replace_response_text(original_response_clone, upstream_domain, url_hostname); } else { original_text = original_response_clone.body } response = new Response(original_text, { status, headers: new_response_headers }) } return response; } async function replace_response_text(response, upstream_domain, host_name) { let text = await response.text() var i, j; for (i in replace_dict) { j = replace_dict[i] if (i == '$upstream') { i = upstream_domain } else if (i == '$custom_domain') { i = host_name } if (j == '$upstream') { j = upstream_domain } else if (j == '$custom_domain') { j = host_name } let re = new RegExp(i, 'g') text = text.replace(re, j); } return text; } async function device_status(user_agent_info) { var agents = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;]; var flag = true; for (var v = 0; v &lt; agents.length; v++) { if (user_agent_info.indexOf(agents[v]) &gt; 0) { flag = false; break; } } return flag; } ","link":"https://loyingxi.github.io/post/shi-yong-cloudflare-zhi-zuo-jing-xiang-zhan/"}]}